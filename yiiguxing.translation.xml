<application>
  <component name="AppStorage">
    <histories>
      <item value="* Inserts the specified element at the tail of this queue if it is * possible to do so immediately without exceeding the queue's capacity, * returning {@code true} upon success and {@code false} if this queue * is full. This method is generally preferable to method {@link #add}, * which can fail to insert an element only by throwing an exception. *" />
      <item value="* &lt;p&gt;{@code BlockingQueue} methods come in four forms, with different ways * of handling operations that cannot be satisfied immediately, but may be * satisfied at some point in the future: * one throws an exception, the second returns a special value (either * {@code null} or {@code false}, depending on the operation), the third * blocks the current thread indefinitely until the operation can succeed, * and the fourth blocks for only a given maximum time limit before giving * up. These methods are summarized in the following table:" />
      <item value="* A {@link java.util.Queue} that additionally supports operations * that wait for the queue to become non-empty when retrieving an * element, and wait for space to become available in the queue when * storing an element." />
      <item value="should Fetch Registry" />
      <item value="keep Alive Time" />
      <item value="* Indicates how often(in seconds) to fetch the registry information from * the eureka server." />
      <item value="Initializes all scheduled tasks." />
      <item value="Fetch" />
      <item value="Responsible for adding in a marker bean to activate" />
      <item value="true if we have to prefer the same zone as the client, false otherwise" />
      <item value="The zone in which the client resides" />
      <item value="Get the list of all eureka service urls from properties file for the eureka client to talk to." />
      <item value="* &lt;tt&gt;Eureka Client&lt;/tt&gt; is responsible for a) &lt;em&gt;Registering&lt;/em&gt; the * instance with &lt;tt&gt;Eureka Server&lt;/tt&gt; b) &lt;em&gt;Renewal&lt;/em&gt;of the lease with * &lt;tt&gt;Eureka Server&lt;/tt&gt; c) &lt;em&gt;Cancellation&lt;/em&gt; of the lease from * &lt;tt&gt;Eureka Server&lt;/tt&gt; during shutdown * &lt;p&gt; * d) &lt;em&gt;Querying&lt;/em&gt; the list of services/instances registered with * &lt;tt&gt;Eureka Server&lt;/tt&gt; * &lt;p&gt;" />
      <item value="The class that is instrumental for interactions with &lt;tt&gt;Eureka Server&lt;/tt&gt;." />
      <item value="Discovery" />
      <item value="* Convenience annotation for clients to enable Eureka discovery configuration * (specifically). Use this (optionally) in case you want discovery and know for sure that * it is Eureka you want. All it does is turn on discovery and let the autoconfiguration * find the eureka classes if they are available (i.e. you need Eureka on the classpath as * well). *" />
      <item value="Circuit" />
      <item value="The most well known and basic load balancing strategy, i.e. Round Robin Rule." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="17" />
        <entry key="ENGLISH" value="18" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>